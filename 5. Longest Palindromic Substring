class Solution:
  def longestPalindrome(self, s: str) -> str:
    #Solution 1: O(n^3) / O(n)
    def isPalindrome(substring):
      return substring == substring[::-1]
    sol = s[0]
    for l in range(len(s)-1):
      for r in range(l+1, len(s)):
        if isPalindrome(s[l:r+1]):
          if len(s[l:r+1]) > len(sol):
            sol = s[l:r+1]
    return sol
    
    #Solution 2 Two Pointer: O(n^2) / O(n)
    def checkPalindrome(l, r):
      while l >= 0 and r < len(s) and s[l] == s[r]:
        l -= 1
        r += 1
      return s[l+1:r]
    sol = s[0]
    for i in range(len(s)):
      if len(checkPalindrome(i, i)) > len(sol):
        sol = checkPalindrome(i, i)
      if i < len(s) - 1 and len(checkPalindrome(i, i+1)) > len(sol):
        sol = checkPalindrome(i, i+1)
    return sol

    #Solution 3: O(n^2) / O(n), Solution #2 without using checkPalindrome(l, r)
    def longestPalindrome(self, s: str) -> str:
      #Solution 1: O(n^2) / O(n)
      sol = s[0]
      for i in range(len(s)-1):
        oddExtend = 1
        while i - oddExtend >= 0 and i + oddExtend < len(s): #odd length palindrome
          if s[i - oddExtend] == s[i + oddExtend]:
            if oddExtend * 2 + 1 > len(sol):
              sol = s[i - oddExtend:i + oddExtend + 1]
          else: break
          oddExtend += 1
        
        if s[i] == s[i+1]: #even length palindrome
          if len(sol) < 2: sol = s[i:i+2]
          evenExtend = 1
          while i - evenExtend >= 0 and i + 1 + evenExtend < len(s):
            if s[i - evenExtend] == s[i + 1 + evenExtend]:
              if evenExtend * 2 + 2 > len(sol):
                sol = s[i - evenExtend: i + 1 + evenExtend + 1]
            else: break
            evenExtend += 1

        return sol
