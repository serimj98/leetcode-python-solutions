class Solution:
  def findPeakElement(self, nums: List[int]) -> int:
    #Solution 1: O(n) / O(1)
    for i in range(len(nums)-1):
      #if increasing only, will return the last element
      #if decreasing only, will return the first element
      #if peak in the middle, will return at first point there is a decreasing trend
      if nums[i+1] < nums[i]: return i
    return len(nums) - 1
  
    #Solution 2: O(log n) / O(1)
    #find the subarray with the higher value when comparing two elements in the middle
    l, r = 0, len(nums) - 1
    if l == r: return 0
    while l <= r:
      m = l + (r - l) // 2
      if (m == 0 or nums[m-1] < nums[m]) and (m == len(nums) - 1 or nums[m+1] < nums[m]):
        return m
      elif nums[m+1] < nums[m]:
        r = m - 1
      else:
        l = m + 1
