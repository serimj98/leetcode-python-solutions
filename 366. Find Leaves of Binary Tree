# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
  def findLeaves(self, root: Optional[TreeNode]) -> List[List[int]]:
    #Solution 1 DFS: O(h log n) / O(n)
    self.sol = []
    self.curLeaves = []
    def recursive(node):
      if not node: return
      if not node.left and not node.right:
        self.curLeaves.append(node.val)
        return
      node.left = recursive(node.left) #will get pruned by getting assigned to None if leaf
      node.right = recursive(node.right)
      return node
    while root:
      root = recursive(root)
      self.sol.append(self.curLeaves)
      self.curLeaves = []
    return self.sol
  
    #Solution 2: O(n) / O(n)
    """
    The leaves of the tree would start with height 0, then +1 as you go up the tree.
    h(1) = max(recursive(2), recursive(3)) + 1 = 2
               h(2) = max(recursive(4), recursive(5)) + 1 = 1
                          h(4) = max(recursive(None), recursive(None)) + 1 = 0
                                     -1               -1
                          h(5) = max(recursive(None), recursive(None)) + 1 = 0
                                     -1               -1
               h(3) = max(recursive(None), recursive(None)) + 1 = 0
                          -1               -1
    """
    self.sol = []
    def recursive(node):
      if not node: return -1
      h = max(recursive(node.left), recursive(node.right)) + 1
      if len(self.sol) <= h:
        self.sol.append([])
      self.sol[h].append(node.val)
      return h
    recursive(root)
    return self.sol
